# 排序算法总结
|分类|内容|时间复杂度| 空间复杂度|算法稳定性|
|-----|-----|-----|----|-----|
|选泡插 | 选择排序、冒泡排序、插入排序|平均 O(n^2) <br>最好 O(n)| O(1)|冒泡排序：稳定<br>选择排序：不稳定<br>插入排序：稳定
|快归希堆|快速排序、归并排序、希尔排序、堆排序| O(log(n))| |快速排序：不稳定<br>归并排序：稳定<br>希尔排序：不稳定<br>堆排序：不稳定
|桶计基|桶排序、计数排序、基数排序|O(n)| | 桶排序：<br>计数排序：<br>基数排序：稳定

## 1. 冒泡排序
### 思路
遍历元素，每一次遍历都将最大或者最小的元素找出，将其移动到最后一个元素的位置，数值像气泡一样一直朝着一个方向移动。这样的话，每一次遍历都把最大或者最小的找出来并排序好，如下：

遍历次数| 数据规模| 数据区间| 未排序区间| 已排序区间| 备注
---|---|---|---|---|---
0| n| [0,n]| [0,n] | [] | 初始化
1| n-1| [0,n-1]| [0,n-1] | (n-1,n] |
2| n-2| [0,n-2]| [0,n-2] | (n-2,n] |
3| n-3| [0,n-3]| [0,n-3] | (n-3,n] |
... | ... |...|...|...|
n-1| 1| (n-1,n]| (n-1,n] | [0,n-1] |
n| 0| []| [] | [0,n] | 排序完成
### 实现方式
可以通过朴素的双循环，也可以抽象出相同逻辑通过递归来实现
#### 遍历
```go
func TestBubbleSort1(t *testing.T) {
	nums := []int{2, 3, 1, 6, 9, 8, 4, 5, 7}

	//这里for循环表示要遍历的趟数
	//第一次遍历全部的[0,n]个，然后排序好的最后一个数是符合预期的（最大或者最小）
	//第二次遍历全部的[0,n-1]个，然后最后两个就被排序好了
	//以此类推
	//i代表每一趟参与遍历的元素数量
	for i := len(nums) ; i >0; i-- {
		//这里for循环代表每一趟比较、交换的过程
		//每次都是从[0,n]的范围，只不过n会每次由外循环传递进来，并且每一趟最后一个会排序好，所以n的数量会递减
		//j代表每次遍历的下标，j<i-1 代表只遍历到数据规模的倒数第二个，因为要进行对比，这里目的是防止索引越界
		for j := 0; j < i-1; j++ {
			//nums[j]代表当前遍历到的元素，nums[j+1]代表下一个
			if nums[j+1] < nums[j] { //判断元素大小
				//交换过程
				tmp := nums[j+1]
				nums[j+1] = nums[j]
				nums[j] = tmp
			}
		}
	}
	//打印
	//[1 2 3 4 5 6 7 8 9]
	fmt.Println(nums)
}
```

#### 递归
```go
//递归
func TestBubbleSort2(t *testing.T) {
	nums := []int{2, 3, 1, 6, 9, 8, 4, 5, 7}
	bubbleSort(nums, len(nums))
	//打印
	fmt.Println(nums)
}

func bubbleSort(nums []int, size int) {
	//不满足两个不需要比较
	if size < 2 {
		return
	}
	//这里for循环代表每一趟比较、交换的过程
	//每次都是从[0,n]的范围，只不过n会每次由外循环传递进来，并且每一趟最后一个会排序好，所以n的数量会递减
	//j代表每次遍历的下标，j<i-1 代表只遍历到数据规模的倒数第二个，因为要进行对比，这里目的是防止索引越界
	for j := 0; j < size-1; j++ {
		//nums[j]代表当前遍历到的元素，nums[j+1]代表下一个
		if nums[j+1] < nums[j] { //判断元素大小
			//交换过程
			tmp := nums[j+1]
			nums[j+1] = nums[j]
			nums[j] = tmp
		}
	}
	//每次数据规模减少1，因为每一次最靠后的都排序好了
	size--
	bubbleSort(nums, size)
}
```
### 优化方式
- 记录当前轮次是否发生过交换，没有发生过交换表示数组已经有序
- 记录上次发生交换的位置，下一轮排序时只比较到此位置

```go
//递归
func TestBubbleSort3(t *testing.T) {
	nums := []int{1,2,3,4,5,6,7,8,9}
	bubbleSort3(nums, len(nums))
	//打印
	fmt.Println(nums)
}

//优化
func bubbleSort3(nums []int, size int) {
	//不满足两个不需要比较
	if size < 2 {
		return
	}
	//增加优化标识，判断是否都排序过了
	sorted := true

	//这里for循环代表每一趟比较、交换的过程
	//每次都是从[0,n]的范围，只不过n会每次由外循环传递进来，并且每一趟最后一个会排序好，所以n的数量会递减
	//j代表每次遍历的下标，j<i-1 代表只遍历到数据规模的倒数第二个，因为要进行对比，这里目的是防止索引越界
	for j := 0; j < size-1; j++ {
		//nums[j]代表当前遍历到的元素，nums[j+1]代表下一个
		if nums[j+1] < nums[j] { //判断元素大小
			//交换过程
			tmp := nums[j+1]
			nums[j+1] = nums[j]
			nums[j] = tmp
			sorted = false
		}
	}
	// 已经排序过的就跳过了
	if sorted {
		return
	}
	//每次数据规模减少1，因为每一次最靠后的都排序好了
	size--
	bubbleSort3(nums, size)
}
```

## 2. 选择排序
### 思路
从头到尾扫描元素，找到最小或者最大的一个，然后和第一个元素互换；
以此类推，每次都会找到最大或者最小的那个元素，然后把它放置在相对靠前位置

遍历次数| 数据规模| 数据区间| 未排序区间| 已排序区间| 备注
---|---|---|---|---|---
0| n| [0,n]| [0,n] | [] | 初始化
1| n-1| [1,n]| [1,n] | [0,1) |
2| n-2| [2,n]| [2,n] | [0,2) |
3| n-3| [3,n]| [3,n] | [0,3) |
... | ... |...|...|...|
n-1| 1| [n-1,n]| [n-1,n] | [0,n-1) |
n| 0| []| [] | [0,n] | 排序完成

### 实现方式
#### 遍历
```go
// 遍历
func TestSelectSort1(t *testing.T) {
	nums := []int{2, 3, 1, 6, 9, 8, 4, 5, 7}

	//这里的for循环是进行n次遍历，每一次的目的是把当前数据规模中最大或者最小的元素找到
	//然后将找到（选择）的这个元素放到当前数据范围的最前面，这样随着遍历的推移，每一次都会找到当前数据规模最大或者最小的元素
	//靠前面的数据已经排好序，靠后面的就是还没被排序的部分
	for i := 0; i < len(nums); i++ {
		//每次遍历取最开头的元素作为游标对象进行对比，通过它来找到最大或者最小的那个元素
		cmp := nums[i]
		//idx用来记录一次遍历后最大或最小元素的索引位置，为后面做交换使用的
		idx := i
		//这里从i+1开始就可以，因为cmp就是i位置的元素，不用和自己对比了
		for j := i+1; j < len(nums); j++ {
			if nums[j] < cmp { //对比元素大小, < 这里是找到最小的， > 的话是找到最大的
				cmp = nums[j]
				idx = j
			}
		}
		//交换元素
		//此时的cmp是这轮遍历后最大或者最小的那个元素值，idx是这个元素的索引，我们要把它放到本次数据范围的最前面
		tmp := nums[idx]
		nums[idx] = nums[i]
		nums[i] = tmp
	}
	fmt.Println(nums)
}
```
#### 递归
```go
// 递归
func TestSelectSort2(t *testing.T) {
	nums := []int{2, 3, 1, 6, 9, 8, 4, 5, 7}

	selectSort(nums,0)

	fmt.Println(nums)
}

func selectSort(nums []int, i int)  {
	//i是数据规模开始的位置，i == len -1 代表当前只有一个元素，此时不需要排序了
	if i == len(nums) -1 {
		return
	}

	//每次遍历取最开头的元素作为游标对象进行对比，通过它来找到最大或者最小的那个元素
	cmp := nums[i]
	//idx用来记录一次遍历后最大或最小元素的索引位置，为后面做交换使用的
	idx := i
	//这里从i+1开始就可以，因为cmp就是i位置的元素，不用和自己对比了
	for j := i+1; j < len(nums); j++ {
		if nums[j] < cmp { //对比元素大小, < 这里是找到最小的， > 的话是找到最大的
			cmp = nums[j]
			idx = j
		}
	}
	//交换元素
	//此时的cmp是这轮遍历后最大或者最小的那个元素值，idx是这个元素的索引，我们要把它放到本次数据范围的最前面
	tmp := nums[idx]
	nums[idx] = nums[i]
	nums[i] = tmp

	//每一次遍历都找到最大或者最小的元素并将其放在了当前数据范围的最开头
	//所以每次i前面都是排序好的，下一次排序从i的下一个开始
	i++
	selectSort(nums,i)
}
```
### 优化方式
选择排序可以演变为**二元选择排序**：
- 一次遍历同时找到**最大值、最小值**
- **剪枝优化**，当某一轮遍历出现**最大值**和**最小值**相等，表示数组中剩余元素已经全部相等

```go
// 递归 + 二元选择、剪枝优化
func TestSelectSort3(t *testing.T) {
	nums := []int{2, 3, 1, 6, 9, 8, 4, 5, 7}

	selectSort3(nums, 0)

	fmt.Println(nums)
}

func selectSort3(nums []int, i int) {
	//i是数据规模开始的位置，i == len -1 代表当前只有一个元素，此时不需要排序了
	if i == len(nums)-1 {
		return
	}

	//每次遍历取最开头的元素作为游标对象进行对比，通过它来找到最大或者最小的那个元素
	min := nums[i]
	max := nums[i]
	//minIdx、maxIdx用来记录一次遍历后最大或最小元素的索引位置，为后面做交换使用的
	minIdx := i             //这里取本次数据范围的第一个为最小值，因为最小的会被放在第一个
	maxIdx := len(nums) - 1 //这里取最后一个为最大的对比，因为最大的会被放在最后一个
	//这里从i+1开始就可以，因为cmp就是i位置的元素，不用和自己对比了
	for j := i + 1; j < len(nums); j++ {
		if nums[j] < min { //对比元素大小, < 这里是找到最小的
			min = nums[j]
			minIdx = j
		}
		if nums[j] > max { //对比元素大小, > 这里是找到最大的
			max = nums[j]
			maxIdx = j
		}
	}

	//剪枝优化
	//最小位置的元素已经是最小，且最大位置的元素已经是最大，则说明剩余数据范围的元素都已经排序好了，可以停止遍历
	if minIdx == i && maxIdx == len(nums)-1 {
		return
	}

	//交换元素
	//此时的min、max是这轮遍历后最大或者最小的那个元素值
	//minIdx是这次遍历最小元素的索引，我妈要把它放到本次数据范围的最前面
	minTmp := nums[minIdx]
	nums[minIdx] = nums[i]
	nums[i] = minTmp
	//maxIdx是这次遍历最大元素的索引，我们要把它放到本次数据范围的最后面
	maxTmp := nums[maxIdx]
	nums[maxIdx] = nums[len(nums)-1]
	nums[len(nums)-1] = maxTmp
	//每一次遍历都找到最大或者最小的元素并将其放在了当前数据范围的最开头
	//所以每次i前面都是排序好的，下一次排序从i的下一个开始
	i++
	selectSort3(nums, i)
}
```

### 排序不稳定原因

## 3. 插入排序
### 思路
构建有序序列，将未排序的数据插入到已排序的数据中，过程和玩扑克牌整理牌面很像
### 实现方式
- **交换法**：新数字通过不断交换找到自己合适的位置；
- **移动法**：旧数字不断向后移动，直到新数字找到合适的位置。

#### 遍历（交换法）
```go
//循环
func TestInsertSort1(t *testing.T) {
	nums := []int{2, 3, 1, 6, 9, 8, 4, 5, 7}

	//遍历n次，每次都把后面未排序的数据和前面已排序好的元素做对比，并插入到前面已排序好的区间内
	//i代表每次数据规模开始的地方，它是递增的，i前面的是已排好序的，i后面的是未排好序的
	for i := 0; i < len(nums); i++ {
		//j代表每一次遍历要对比的元素
		//由于上面提到 i 前面都是排序完成的，i后面都是未排序的
		//因此 j = i 是选取未排序的第一个元素来进行和i 前面未排序的元素依次对比完成本次排序
		for j := i; j > 0; j-- {
			if nums[j] < nums[j-1] { // > 把较小的往前移; < 把较大的往前移
				//交换元素
				tmp := nums[j]
				nums[j] = nums[j-1]
				nums[j-1] = tmp
			}
		}
	}
	fmt.Println(nums)
}
```
#### 递归（交换法）
```go
//递归
func TestInsertSort2(t *testing.T) {
	nums := []int{2, 3, 1, 6, 9, 8, 4, 5, 7}
	insertSort(nums, 1)
	fmt.Println(nums)
}

func insertSort(nums []int, i int) {
	//当i超过nums长度就停止
	if i <= 0 || i >= len(nums) {
		return
	}

	//j代表每一次遍历要对比的元素
	//由于上面提到 i 前面都是排序完成的，i后面都是未排序的
	//因此 j = i 是选取未排序的第一个元素来进行和i 前面未排序的元素依次对比完成本次排序
	for j := i; j > 0; j-- {
		if nums[j] < nums[j-1] { // > 把较小的往前移; < 把较大的往前移
			//交换元素
			tmp := nums[j]
			nums[j] = nums[j-1]
			nums[j-1] = tmp
		}
	}
	//每一轮排序完，i递增，从下一个继续开始
	i++
	insertSort(nums, i)
}
```
### 优化方式
- 对已经排好序的部分进行**二分查找**
- 一次遍历携带多个元素
- 希尔排序

## 小结
- **相同点**
  时间复杂度都是 O(n^2) ，空间复杂度都是 O(1)，都需要采用两重循环。

- **不同点**
  选择排序是不稳定的，冒泡排序、插入排序是稳定的；
  在这三个排序算法中，选择排序交换的次数是最少的；
  在数组几乎有序的情况下，插入排序的时间复杂度接近线性级别。

## 4. 希尔排序
它是插入排序的一种，是对插入排序的优化，1959年由D.L.Shell提出，因此得名。基本思想是把待排序的数列分为多个组，然后再对每个组进行插入排序，先让数列整体大致有序，然后多次调整分组方式，使数列更加有序，最后再使用一次插入排序，让整个数列全部有序

希尔排序也叫**缩小增量排序**，增量的选取是一个数学难题，没有准确的说法，
n/2，例如5 -> 3 -> 1
## 快速排序
### 核心点
**找到基准值的位置**
### 步骤
- 第一步，选择一个值作为基准值；
- 第二步，找到基准值的位置，并将小于基准值的元素放在基准值的前面，大于基准值的元素放在基准值的后面；
- 第三步，对基准值的左右两侧递归地进行这个过程。
> 挖坑填数 + 分治

### 实现方式

```go

func TestQuickSort1(t *testing.T) {
	nums := []int{2, 3, 1, 6, 9, 8, 4, 5, 7}

	quickSort(nums, 0, len(nums)-1)
	fmt.Println(nums)
}

// nums数据元素
// left左下标
// right右下标
func quickSort(nums []int, left, right int) {
	// 左下标大于等于右下标退出，此时数据规模不再需要排序
	if left >= right {
		return
	}
	//基准值，这里设置为取每次数据规模的左下标起始位置的元素作为中轴线
	pivot := nums[left]
	//左下标
	leftIdx := left
	//右下标
	rightIdx := right

	//只要左下标小于右下标就运行，等于时说明左右下标重合，此时不需要执行
	for leftIdx < rightIdx {
		//移动左
		for nums[leftIdx] < pivot {
			leftIdx++
		}
		for nums[rightIdx] > pivot {
			rightIdx--
		}
		nums[leftIdx], nums[rightIdx] = nums[rightIdx], nums[leftIdx]
	}
	//此时循环结束，左右下标重合，将基准值放入
	nums[leftIdx] = pivot
	quickSort(nums, left, leftIdx-1)
	quickSort(nums, rightIdx+1, right)
}
```

### 优化
- 采用更合理的**基准数(中心轴)**，减少递归的深度，从数列中选取多个数，取中间数
- 结合插入排序，区间在10个元素之内采用插入排序，效率更高
# 参考
[Golang实现常见排序算法](https://blog.csdn.net/hello_wcx/article/details/108339639)
[十大经典排序算法](https://www.bilibili.com/video/BV1Ur4y1w7tv?p=1)