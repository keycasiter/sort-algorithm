### 思路
构建有序序列，将未排序的数据插入到已排序的数据中，过程和玩扑克牌整理牌面很像
### 实现方式
- **交换法**：新数字通过不断交换找到自己合适的位置；
- **移动法**：旧数字不断向后移动，直到新数字找到合适的位置。

#### 遍历（交换法）
```go
//循环
func TestInsertSort1(t *testing.T) {
	nums := []int{2, 3, 1, 6, 9, 8, 4, 5, 7}

	//遍历n次，每次都把后面未排序的数据和前面已排序好的元素做对比，并插入到前面已排序好的区间内
	//i代表每次数据规模开始的地方，它是递增的，i前面的是已排好序的，i后面的是未排好序的
	for i := 0; i < len(nums); i++ {
		//j代表每一次遍历要对比的元素
		//由于上面提到 i 前面都是排序完成的，i后面都是未排序的
		//因此 j = i 是选取未排序的第一个元素来进行和i 前面未排序的元素依次对比完成本次排序
		for j := i; j > 0; j-- {
			if nums[j] < nums[j-1] { // > 把较小的往前移; < 把较大的往前移
				//交换元素
				tmp := nums[j]
				nums[j] = nums[j-1]
				nums[j-1] = tmp
			}
		}
	}
	fmt.Println(nums)
}
```
#### 递归（交换法）
```go
//递归
func TestInsertSort2(t *testing.T) {
	nums := []int{2, 3, 1, 6, 9, 8, 4, 5, 7}
	insertSort(nums, 1)
	fmt.Println(nums)
}

func insertSort(nums []int, i int) {
	//当i超过nums长度就停止
	if i <= 0 || i >= len(nums) {
		return
	}

	//j代表每一次遍历要对比的元素
	//由于上面提到 i 前面都是排序完成的，i后面都是未排序的
	//因此 j = i 是选取未排序的第一个元素来进行和i 前面未排序的元素依次对比完成本次排序
	for j := i; j > 0; j-- {
		if nums[j] < nums[j-1] { // > 把较小的往前移; < 把较大的往前移
			//交换元素
			tmp := nums[j]
			nums[j] = nums[j-1]
			nums[j-1] = tmp
		}
	}
	//每一轮排序完，i递增，从下一个继续开始
	i++
	insertSort(nums, i)
}
```
### 优化方式
- 对已经排好序的部分进行**二分查找**
- 一次遍历携带多个元素
- 希尔排序

## 小结
- **相同点**
  时间复杂度都是 O(n^2) ，空间复杂度都是 O(1)，都需要采用两重循环。

- **不同点**
  选择排序是不稳定的，冒泡排序、插入排序是稳定的；
  在这三个排序算法中，选择排序交换的次数是最少的；
  在数组几乎有序的情况下，插入排序的时间复杂度接近线性级别。
